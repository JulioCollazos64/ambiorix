% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parser.R
\name{parse_req}
\alias{parse_req}
\title{Parse HTTP request}
\usage{
parse_req(
  req,
  content_type = NULL,
  fields_to_extract = character(),
  new_field_names = character()
)
}
\arguments{
\item{req}{A request object. The request must include a \code{CONTENT_TYPE} header
and a body accessible via \code{req$rook.input$read()}.}

\item{content_type}{String. 'Content-Type' of the request. See details for
valid values.
By default, this parameter is set to \code{NULL} and is inferred from the \code{req}
object during run time.
The only time you need to provide this argument is if \code{req$CONTENT_TYPE}
is different from how you want the request body to be parsed.
For example, \code{req$CONTENT_TYPE} gives "text/plain;charset=UTF-8" but you want
to parse the request body as "application/json".}

\item{fields_to_extract}{Character vector specifying the names of fields to
extract from the parsed request body. If missing, returns all
fields found after parsing of the HTTP request.}

\item{new_field_names}{Character vector of same length as
\code{fields_to_extract}. Specifies new names to assign to the extracted fields
in the returned list. Useful for renaming the fields for clarity or
consistency in the output. If not provided or empty (default), the
original names in \code{fields_to_extract} are used.}
}
\value{
Named list containing the extracted fields and their associated
values. If no data is found or an error occurs, an empty list is returned.
}
\description{
Parses the body of an HTTP request based on its \code{Content-Type} header. This
function simplifies working with HTTP requests by extracting specific data
fields from the parsed body.
}
\details{
Supported \code{Content-Type} values include:
\itemize{
\item \code{multipart/form-data}
\item \code{application/json}
\item \code{application/x-www-form-urlencoded}
}

The \code{fields_to_extract} & \code{new_field_names} parameters \strong{only}
used for 'multipart/form-data' and 'application/x-www-form-urlencoded'.

For 'multipart/form-data', if a field is a file upload it is returned as a named list with:
\itemize{
\item \code{value}: Raw vector representing the file contents. You must
process this further (eg. convert to data.frame). See the examples section.
\item \code{content_disposition}: Typically "form-data", indicating how the content
is meant to be handled.
\item \code{content_type}: MIME type of the uploaded file (e.g., "image/png" or "application/pdf").
\item \code{name}: Name of the form input field.
\item \code{filename}: Original name of the uploaded file.
}
}
\examples{
if (interactive()) {
  library(ambiorix)
  library(htmltools)
  library(readxl)

  page_links <- \() {
    Map(
      f = \(href, label) {
        tags$a(href = href, label)
      },
      c("/", "/about", "/contact"),
      c("Home", "About", "Contact")
    )
  }

  forms <- \() {
    form1 <- tags$form(
      action = "/url-form-encoded",
      method = "GET",
      enctype = "application/x-www-form-urlencoded",
      tags$h4("form-url-encoded:"),
      tags$label(`for` = "first_name", "First Name"),
      tags$input(id = "first_name", name = "first_name", value = "John"),
      tags$label(`for` = "last_name", "Last Name"),
      tags$input(id = "last_name", name = "last_name", value = "Coene"),
      tags$button(type = "submit", "Submit")
    )

    form2 <- tags$form(
      action = "/multipart-form-data",
      method = "POST",
      enctype = "multipart/form-data",
      tags$h4("multipart/form-data:"),
      tags$label(`for` = "email", "Email"),
      tags$input(id = "email", name = "email", value = "john@mail.com"),
      tags$label(`for` = "framework", "Framework"),
      tags$input(id = "framework", name = "framework", value = "ambiorix"),
      tags$label(`for` = "file", "Upload CSV file"),
      tags$input(type = "file", id = "file", name = "file", accept = ".csv"),
      tags$label(`for` = "file2", "Upload xlsx file"),
      tags$input(type = "file", id = "file2", name = "file2", accept = ".xlsx"),
      tags$button(type = "submit", "Submit")
    )

    form3 <- tags$form(
      action = "/multipart-form-data2",
      method = "POST",
      enctype = "multipart/form-data",
      tags$h4("multipart/form-data (specific fields extracted & renamed):"),
      tags$label(`for` = "family_name", "Family Name"),
      tags$input(id = "family_name", name = "family_name", value = "the johns"),
      tags$label(`for` = "user_book", "User Book"),
      tags$input(id = "user_book", name = "user_book", value = "JavaScript for R"),
      tags$label(`for` = "user_age", "User Age"),
      tags$input(id = "user_age", name = "user_age", value = "15"),
      tags$button(type = "submit", "Submit")
    )

    tagList(form1, form2, form3)
  }

  home_get <- \(req, res) {
    html <- tagList(
      page_links(),
      tags$h3("hello, world!"),
      forms()
    )

    res$send(html)
  }

  url_form_encoded_get <- \(req, res) {
    query <- req$query
    list_items <- lapply(
      X = names(query),
      FUN = \(nm) {
        tags$li(
          nm,
          ":",
          query[[nm]]
        )
      }
    )
    input_vals <- tags$ul(list_items)

    html <- tagList(
      page_links(),
      tags$h3("Request processed"),
      input_vals
    )

    res$send(html)
  }

  multipart_form_data_post <- \(req, res) {
    body <- parse_req(req)

    list_items <- lapply(
      X = names(body),
      FUN = \(nm) {
        field <- body[[nm]]

        # if 'field' is a file, parse it & print on console:
        is_file <- "filename" \%in\% names(field)
        is_csv <- is_file && identical(field[["content_type"]], "text/csv")
        is_xlsx <- is_file &&
          identical(
            field[["content_type"]],
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
          )

        if (is_file) {
          file_path <- tempfile()
          writeBin(object = field$value, con = file_path)
          on.exit(unlink(x = file_path))
        }

        if (is_csv) {
          read.csv(file = file_path) |> print()
        }

        if (is_xlsx) {
          readxl::read_xlsx(path = file_path) |> print()
        }

        tags$li(
          nm,
          ":",
          if (is_file) "printed on console" else field
        )
      }
    )
    input_vals <- tags$ul(list_items)

    html <- tagList(
      page_links(),
      tags$h3("Request processed"),
      input_vals
    )

    res$send(html)
  }

  multipart_form_data_post2 <- \(req, res) {
    body <- parse_req(
      req,
      fields_to_extract = c("user_book", "user_age"),
      new_field_names = c("book", "age")
    )

    list_items <- lapply(
      X = names(body),
      FUN = \(nm) {
        tags$li(nm, ":", body[[nm]])
      }
    )
    input_vals <- tags$ul(list_items)

    html <- tagList(
      page_links(),
      tags$h3("Request processed, only these fields extracted & renamed:"),
      input_vals
    )

    res$send(html)
  }

  about_get <- \(req, res) {
    html <- tagList(
      page_links(),
      tags$h3("About Us")
    )
    res$send(html)
  }

  contact_get <- \(req, res) {
    html <- tagList(
      page_links(),
      tags$h3("Get In Touch!")
    )
    res$send(html)
  }

  home_post <- \(req, res) {
    body <- parse_req(req)
    response <- list(
      code = 200L,
      msg = "hello, world"
    )
    res$json(response)
  }

  app <- Ambiorix$new(port = 5000L)

  app$
    get("/", home_get)$
    post("/", home_post)$
    get("/about", about_get)$
    get("/contact", contact_get)$
    get("/url-form-encoded", url_form_encoded_get)$
    post("/multipart-form-data", multipart_form_data_post)$
    post("/multipart-form-data2", multipart_form_data_post2)

  app$start()
}
}
